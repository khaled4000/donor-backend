const express = require('express');
const Donation = require('../models/Donation');
const Case = require('../models/Case');
const { auth, isDonor } = require('../middleware/auth');
const { requireDonorEmailVerification } = require('../middleware/emailVerification');
const router = express.Router();

// Make a donation
router.post('/', auth, isDonor, requireDonorEmailVerification, async (req, res) => {
  try {
    const { caseId, amount, paymentMethod = 'credit_card', anonymous = false, message } = req.body;

    // Validation
    if (!caseId || !amount) {
      return res.status(400).json({
        message: 'Case ID and amount are required',
        fields: {
          caseId: !caseId ? ['Case ID is required'] : undefined,
          amount: !amount ? ['Amount is required'] : undefined,
        },
      });
    }

    if (amount <= 0) {
      return res.status(400).json({
        message: 'Please enter a valid donation amount',
        fields: { amount: ['Amount must be greater than 0'] },
      });
    }

    // Find the case
    const caseItem = await Case.findOne({ caseId, status: 'approved' });
    if (!caseItem) {
      return res.status(404).json({ message: 'Case not found or not available for donations' });
    }

    // Validate case data
    if (!caseItem.familyData || !caseItem.familyData.familyName || !caseItem.familyData.village) {
      console.error('âŒ Invalid case data:', {
        hasFamilyData: !!caseItem.familyData,
        familyName: caseItem.familyData?.familyName,
        village: caseItem.familyData?.village,
      });
      return res.status(400).json({
        message: 'Case data is incomplete',
        details: 'Family information is missing or incomplete',
      });
    }

    // Check if case is already fully funded
    if (caseItem.status === 'fully_funded' || caseItem.donationProgress >= 100) {
      return res.status(400).json({ message: 'This case is already fully funded' });
    }

    // Create donation record
    const donorName = anonymous ? 'Anonymous Donor' : (req.user.name || `${req.user.firstName || ''} ${req.user.lastName || ''}`.trim() || 'Unknown Donor');

    const donationData = {
      caseId: caseItem.caseId,
      caseObjectId: caseItem._id,
      donorId: req.user._id,
      donorName: donorName,
      donorEmail: req.user.email,
      familyName: caseItem.familyData.familyName,
      location: `${caseItem.familyData.village}, South Lebanon`,
      village: caseItem.familyData.village,
      amount: parseFloat(amount),
      paymentMethod,
      anonymous,
      message: message || '',
      paymentStatus: 'completed',
      source: 'donor_dashboard',
      ipAddress: req.ip,
      userAgent: req.get('User-Agent'),
    };

    // Validate required fields before creating donation
    if (!donationData.donorName || !donationData.donorEmail || !donationData.familyName || !donationData.village) {
      console.error('âŒ Missing required fields:', {
        donorName: donationData.donorName,
        donorEmail: donationData.donorEmail,
        familyName: donationData.familyName,
        village: donationData.village,
      });
      return res.status(400).json({
        message: 'Missing required case or user information',
        details: {
          donorName: !donationData.donorName ? 'Donor name is missing' : undefined,
          donorEmail: !donationData.donorEmail ? 'Donor email is missing' : undefined,
          familyName: !donationData.familyName ? 'Family name is missing' : undefined,
          village: !donationData.village ? 'Village is missing' : undefined,
        },
      });
    }

    console.log('ðŸ” Creating donation record with data:', donationData);
    console.log('ðŸ” User object:', {
      _id: req.user._id,
      name: req.user.name,
      firstName: req.user.firstName,
      lastName: req.user.lastName,
      email: req.user.email,
    });
    console.log('ðŸ” Case object:', {
      caseId: caseItem.caseId,
      _id: caseItem._id,
      familyName: caseItem.familyData.familyName,
      village: caseItem.familyData.village,
    });

    const donationFields = {
      caseId: caseItem.caseId,
      caseObjectId: caseItem._id,
      donorId: req.user._id,
      donorName: donorName,
      donorEmail: req.user.email,
      familyName: caseItem.familyData.familyName,
      location: `${caseItem.familyData.village}, South Lebanon`,
      village: caseItem.familyData.village,
      amount: parseFloat(amount),
      paymentMethod,
      anonymous,
      message: message || '',
      paymentStatus: 'completed',
      source: 'donor_dashboard',
      ipAddress: req.ip,
      userAgent: req.get('User-Agent'),
      // donationId will be auto-generated by the pre-save hook
    };

    console.log('ðŸ” Donation fields being passed to constructor:', donationFields);

    const donation = new Donation(donationFields);

    console.log('ðŸ” Donation object created, about to save...');
    await donation.save();
    console.log('âœ… Donation saved successfully');

    // Update case with new donation amount
    console.log('ðŸ” Updating case with donation amount:', parseFloat(amount));
    console.log('ðŸ” Case before update:', {
      totalRaised: caseItem.totalRaised,
      totalNeeded: caseItem.totalNeeded,
      donationProgress: caseItem.donationProgress,
    });

    try {
      caseItem.totalRaised += parseFloat(amount);
      
      // Calculate donation progress
      if (caseItem.totalNeeded > 0) {
        caseItem.donationProgress = Math.min(Math.round((caseItem.totalRaised / caseItem.totalNeeded) * 100), 100);
        
        // Auto-update status to fully_funded when progress reaches 100%
        if (caseItem.donationProgress >= 100 && caseItem.status === 'approved') {
          caseItem.status = 'fully_funded';
          if (!caseItem.fullyFundedAt) {
            caseItem.fullyFundedAt = new Date();
          }
          console.log('ðŸŽ‰ Case is now fully funded! Status updated to:', caseItem.status);
        }
      }

      console.log('ðŸ” Case after update:', {
        totalRaised: caseItem.totalRaised,
        totalNeeded: caseItem.totalNeeded,
        donationProgress: caseItem.donationProgress,
        status: caseItem.status,
        fullyFundedAt: caseItem.fullyFundedAt,
      });

      await caseItem.save();
      console.log('âœ… Case updated successfully');
    } catch (caseUpdateError) {
      console.error('âŒ Error updating case:', caseUpdateError);
      // Don't fail the donation if case update fails
      console.log('âš ï¸ Continuing with donation success response...');
    }

    res.status(201).json({
      message: 'Donation successful',
      donation: {
        id: donation.donationId,
        caseId: donation.caseId,
        familyName: donation.familyName,
        location: donation.location,
        amount: donation.amount,
        date: donation.donationDate,
        donorName: donation.getDisplayName(),
        donorEmail: anonymous ? undefined : donation.donorEmail,
        paymentMethod: donation.paymentMethod,
        transactionId: donation.donationId, // Using donation ID as transaction ID for now
        status: donation.paymentStatus,
        message: donation.message,
      },
      updatedCase: {
        raised: `$${caseItem.totalRaised.toLocaleString()}`,
        progress: caseItem.donationProgress,
        totalRaised: caseItem.totalRaised,
      },
    });
  } catch (error) {
    console.error('âŒ Donation error:', error);
    console.error('âŒ Error details:', {
      name: error.name,
      message: error.message,
      stack: error.stack,
    });

    // Check for specific error types
    if (error.name === 'ValidationError') {
      console.error('âŒ Validation errors:', error.errors);
      console.error('âŒ Validation error details:', Object.keys(error.errors).map(key => ({
        field: key,
        message: error.errors[key].message,
        value: error.errors[key].value,
        kind: error.errors[key].kind,
      })));
      return res.status(400).json({
        message: 'Validation failed',
        errors: Object.keys(error.errors).map(key => ({
          field: key,
          message: error.errors[key].message,
        })),
      });
    }

    if (error.name === 'MongoError' && error.code === 11000) {
      return res.status(400).json({
        message: 'Duplicate donation detected',
      });
    }

    res.status(500).json({
      message: 'Server error during donation processing',
      error: error.message,
      type: error.name,
    });
  }
});

// Get donation history for authenticated donor
router.get('/history', auth, isDonor, async (req, res) => {
  try {
    const { limit = 20, offset = 0 } = req.query;

    const donations = await Donation.find({
      donorId: req.user._id,
      paymentStatus: 'completed',
    })
      .sort({ donationDate: -1 })
      .limit(parseInt(limit))
      .skip(parseInt(offset));

    const total = await Donation.countDocuments({
      donorId: req.user._id,
      paymentStatus: 'completed',
    });

    const formattedDonations = donations.map(donation => ({
      id: donation.donationId,
      caseId: donation.caseId,
      familyName: donation.familyName,
      location: donation.location,
      village: donation.village,
      amount: donation.amount,
      date: donation.donationDate,
      status: donation.paymentStatus,
      paymentMethod: donation.paymentMethod,
      message: donation.message,
      anonymous: donation.anonymous,
    }));

    // Calculate user stats
    const stats = await Donation.getTotalDonationsByUser(req.user._id);

    // Get this month's donations
    const currentDate = new Date();
    const monthlyStats = await Donation.getMonthlyDonations(
      req.user._id,
      currentDate.getFullYear(),
      currentDate.getMonth() + 1,
    );

    res.json({
      message: 'Donation history fetched successfully',
      donations: formattedDonations,
      total,
      stats: {
        totalDonated: stats.totalAmount,
        familiesHelped: stats.familiesHelped,
        thisMonth: monthlyStats.totalAmount,
        totalDonations: stats.totalDonations,
      },
    });
  } catch (error) {
    console.error('Get donation history error:', error);
    res.status(500).json({ message: 'Server error' });
  }
});

// Get donor statistics
router.get('/stats', auth, isDonor, async (req, res) => {
  try {
    const stats = await Donation.getTotalDonationsByUser(req.user._id);

    const currentDate = new Date();
    const monthlyStats = await Donation.getMonthlyDonations(
      req.user._id,
      currentDate.getFullYear(),
      currentDate.getMonth() + 1,
    );

    // Get last donation
    const lastDonation = await Donation.findOne({
      donorId: req.user._id,
      paymentStatus: 'completed',
    }).sort({ donationDate: -1 });

    const averageDonation = stats.totalDonations > 0 ?
      stats.totalAmount / stats.totalDonations : 0;

    res.json({
      message: 'Donor statistics fetched successfully',
      stats: {
        totalDonated: stats.totalAmount,
        familiesHelped: stats.familiesHelped,
        thisMonth: monthlyStats.totalAmount,
        totalDonations: stats.totalDonations,
        averageDonation: Math.round(averageDonation * 100) / 100,
        lastDonation: lastDonation ? lastDonation.donationDate : null,
      },
    });
  } catch (error) {
    console.error('Get donor stats error:', error);
    res.status(500).json({ message: 'Server error' });
  }
});

// Get donations for a specific case (public, for case details)
router.get('/case/:caseId', async (req, res) => {
  try {
    const { limit = 10, offset = 0 } = req.query;

    const donations = await Donation.find({
      caseId: req.params.caseId,
      paymentStatus: 'completed',
    })
      .sort({ donationDate: -1 })
      .limit(parseInt(limit))
      .skip(parseInt(offset));

    const stats = await Donation.getTotalDonationsByCase(req.params.caseId);

    const formattedDonations = donations.map(donation => ({
      id: donation.donationId,
      donorName: donation.getDisplayName(),
      amount: donation.amount,
      date: donation.donationDate,
      message: donation.message,
      anonymous: donation.anonymous,
    }));

    res.json({
      message: 'Case donations fetched successfully',
      donations: formattedDonations,
      stats: {
        totalRaised: stats.totalRaised,
        donationCount: stats.donationCount,
        uniqueDonors: stats.uniqueDonors,
      },
    });
  } catch (error) {
    console.error('Get case donations error:', error);
    res.status(500).json({ message: 'Server error' });
  }
});

// Get recent donations (public, for homepage/dashboard)
router.get('/recent', async (req, res) => {
  try {
    const { limit = 5 } = req.query;

    const donations = await Donation.find({
      paymentStatus: 'completed',
    })
      .sort({ donationDate: -1 })
      .limit(parseInt(limit));

    const formattedDonations = donations.map(donation => ({
      id: donation.donationId,
      donorName: donation.getDisplayName(),
      familyName: donation.familyName,
      village: donation.village,
      amount: donation.amount,
      date: donation.donationDate,
      message: donation.message,
    }));

    res.json({
      message: 'Recent donations fetched successfully',
      donations: formattedDonations,
    });
  } catch (error) {
    console.error('Get recent donations error:', error);
    res.status(500).json({ message: 'Server error' });
  }
});

// Cancel/refund donation (admin only - simplified implementation)
router.post('/:donationId/cancel', auth, async (req, res) => {
  try {
    // Only allow admin/checker to cancel donations
    if (req.user.role !== 'checker') {
      return res.status(403).json({ message: 'Access denied' });
    }

    const { reason } = req.body;

    const donation = await Donation.findOne({ donationId: req.params.donationId });
    if (!donation) {
      return res.status(404).json({ message: 'Donation not found' });
    }

    if (donation.paymentStatus !== 'completed') {
      return res.status(400).json({ message: 'Cannot cancel non-completed donation' });
    }

    // Update donation status
    donation.paymentStatus = 'refunded';
    await donation.save();

    // Update case totals
    const caseItem = await Case.findOne({ caseId: donation.caseId });
    if (caseItem) {
      caseItem.totalRaised = Math.max(0, caseItem.totalRaised - donation.amount);
      caseItem.updateDonationProgress();
      await caseItem.save();
    }

    res.json({
      message: 'Donation cancelled successfully',
      donation: {
        id: donation.donationId,
        status: donation.paymentStatus,
        amount: donation.amount,
        reason,
      },
    });
  } catch (error) {
    console.error('Cancel donation error:', error);
    res.status(500).json({ message: 'Server error' });
  }
});

// Get donation analytics (admin only)
router.get('/analytics', auth, async (req, res) => {
  try {
    if (req.user.role !== 'checker') {
      return res.status(403).json({ message: 'Access denied' });
    }

    const { period = '30d' } = req.query;

    // Calculate date range
    const startDate = new Date();
    switch (period) {
    case '7d':
      startDate.setDate(startDate.getDate() - 7);
      break;
    case '30d':
      startDate.setDate(startDate.getDate() - 30);
      break;
    case '90d':
      startDate.setDate(startDate.getDate() - 90);
      break;
    case '1y':
      startDate.setFullYear(startDate.getFullYear() - 1);
      break;
    default:
      startDate.setDate(startDate.getDate() - 30);
    }

    const analytics = await Donation.aggregate([
      {
        $match: {
          paymentStatus: 'completed',
          donationDate: { $gte: startDate },
        },
      },
      {
        $group: {
          _id: null,
          totalAmount: { $sum: '$amount' },
          totalDonations: { $sum: 1 },
          uniqueDonors: { $addToSet: '$donorId' },
          uniqueCases: { $addToSet: '$caseObjectId' },
          avgDonation: { $avg: '$amount' },
        },
      },
      {
        $project: {
          _id: 0,
          totalAmount: 1,
          totalDonations: 1,
          uniqueDonors: { $size: '$uniqueDonors' },
          uniqueCases: { $size: '$uniqueCases' },
          avgDonation: { $round: ['$avgDonation', 2] },
        },
      },
    ]);

    const result = analytics[0] || {
      totalAmount: 0,
      totalDonations: 0,
      uniqueDonors: 0,
      uniqueCases: 0,
      avgDonation: 0,
    };

    res.json({
      message: 'Analytics fetched successfully',
      period,
      analytics: result,
    });
  } catch (error) {
    console.error('Get analytics error:', error);
    res.status(500).json({ message: 'Server error' });
  }
});

module.exports = router;
